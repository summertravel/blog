---
title: 开发问题总结
date: 2017-10-30 12:24:59
tags: 学习
---
# Android 布局优化
减少布局层级绘制，通过Show GPU Overdraw去检测Overdraw，
    有一点是去除Window的背景：getWindow.setbackgroundDrawble(null);

LinearLayout在没有weight的时候调用一次没有设置weight的view的measure，其次会再一次调用weight>0的view的measure方法，相当于绘制两次。

RelativeLayout会绘制两次，因为view没有顺序而言，AB两个子view可能存在的依赖关系，会使得横向，纵向上都需要绘制一次。RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。

#     RecycleView
1. 解决RecyclerView notifyItem闪屏问题：
    闪烁主要由于RecyclerView使用的默认的动画导致的，所以解决的方法就是修改默认的动画。
    http://www.th7.cn/Program/Android/201612/1038467.shtml

2. getLayoutPotion:对recycleview的item做出的增删导致postion位置发生变化，adapter的刷新并不是及时的，此方法返回的是当前item经过一系列变换后所处的真正位置。
3. notifidatasetchaged()列表不刷新问题：adapter监听的是数据集合的内存地址是否发生了变化，如果datalist = templist;adapter保存的是之前datalist的内存地址的引用，此使用使temlsit的内存地址引用指向了datalist，实际上之前的datalist的内存地址并没有改变。所以也就导致了数据列表不会刷新。
3. 最近做的项目中遇到了ScrollView嵌套RecyclerView，刚写完功能测试，直接卡出翔了，后来通过网上查找资料和
自己的实践，找出了两种方法解决这个问题。
首先来个最简单的方法：
recyclerView.setNestedScrollingEnabled(false);这个方法就可以解决这一问题。



# RxJava
1. todolist()把数据转化为list;
    
2. RecyclerView setHasFixedSize(true); 
```
void onItemsInsertedOrRemoved() {
   if (hasFixedSize) layoutChildren();
   else requestLayout();
}
```
requestLayout()是很昂贵的,因为他会要求重新布局，重新绘制（详细请看Android优化），所以如当不是瀑布流时，设置这个可以避免重复的增删造成而外的浪费资源
    

# 融云的小坑
1. RongIM和RongIMClient的区别，初始化的时候使用RongIM.init();
2. 设置用户信息时实现的UserInfoProvider接口的getUserInfo方法，不生效。  
正确使用：
```
/**
 * 设置用户信息的提供者，供 RongIM 调用获取用户名称和头像信息。
 *
 * @param userInfoProvider 用户信息提供者。
 * @param isCacheUserInfo  设置是否由 IMKit 来缓存用户信息。<br>
 *                         如果 App 提供的 UserInfoProvider
 *                         每次都需要通过网络请求用户数据，而不是将用户数据缓存到本地内存，会影响用户信息的加载速度；<br>
 *                         此时最好将本参数设置为 true，由 IMKit 将用户信息缓存到本地内存中。
 * @see UserInfoProvider
 */
RongIM.setUserInfoProvider(new RongIM.UserInfoProvider() {

    @Override
    public UserInfo getUserInfo(String userId) {

        return findUserById(userId);//根据 userId 去你的用户系统里查询对应的用户信息返回给融云 SDK。
    }

}, true);
```
很多时候 getUserInfo 这个方法会去 App 服务器异步获取用户信息，不能实时返回用户信息。这种情况下，请在成功获取到用户信息的异步回调中使用下面方法来刷新信息。

刷新用户信息：
```
/**
 * 刷新用户缓存数据。
 *
 * @param userInfo 需要更新的用户缓存数据。
 */
RongIM.getInstance().refreshUserInfoCache(new UserInfo("userId", "啊明", Uri.parse("http://rongcloud-web.qiniudn.com/docs_demo_rongcloud_logo.png")));
```
应用在后台的收到的Notification,必须先设置用户提供者，才会有弹窗。融云默认应用在前台不会弹出通知栏的消息，打开会话界面，会自动清除通知栏的消息。

# Dialog的使用
在styl中注明样式，继承Dialog，在oncrea中，设置Dialog布局的文件，默认居中展示，可设置Gravity.的属性，也可设置动画效果
# 异常能不抛出就不抛出，尽量捕获异常
# 关于Retrofit
json解析的不对应导致进不到onNext，比如json是一个数组当成了一个对象来接收了，或者是一个Object当成一个String来接收了。还有就是可能是HTTPCODE没有对应上。
1.dialog必须在一个actiivty上展示。这里开发种有一个问题就是获取堆栈里的第一个activity,APPManager在baseActivity中添加，但是忘记了在destory中销毁。导致获取到栈顶的activity已经被销毁，从而显示dialog异常。

# 机型适配
- 三星某些机型拍照的时候获取不到图片，拍完照后会调转屏幕，导致activity重新加载，需要调用onSaveBuddle那个方法。

# Token
1. 银行采用几分钟一刷新的Token方法，拿旧的token去生成新的Token，一旦旧的Token被申请两次，那么就让两端都去重新登陆，因为此时不能判断哪个是真的。

# Activity
1.setResult()方法是在finish之前完成的，finish方法不一定会在onpause,onStop()之前调用，此时可在onBackPress(),监听返回键，来setResult。
#  PopupWindow在Android7.0系统中显示位置错误
重写popWindows的showAsDropDown方法：

```
    @Override
    public void showAsDropDown(View anchor) {
        if(Build.VERSION.SDK_INT >= 24) {
            Rect rect = new Rect();
            anchor.getGlobalVisibleRect(rect);
            int h = anchor.getResources().getDisplayMetrics().heightPixels - rect.bottom;
            setHeight(h);
        }
        super.showAsDropDown(anchor);
    }
```
#  在导入一个项目的时候编译不通过
情景再现：缺少medule的.iml文件，编译失败。 
    
解决：gradle的编译版本过低，当时项目的版本是1.5。

拓展：在编译的问题上，androidstudio采用的是gradle编译，此时从各个.gradle入手，仔细查看报错日志，看清楚问题。一般as都有相应tips，stackflow是这种问题解决的好地方。

# Json解析问题
情景再现：同一个接口返回不同的数据类型，此时用Object接收，解析报错：java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to com.lj.live.bean.UserInfoBean；
解决方案：把map转成json字符串，然后再利用Gson转成所需的bean；
拓展：在面对两种数据类型的时候，利用捕获异常达到目的。

# Activity启动模式
SingTask
    情景再现：当启动页为此启动模式时，那么从此界面开启的界面，都会在点击home键以后，再点击app，除了启动页外所有的界面都会销毁，启动页会执行onNewIntent(),这里应该和lauch的源码有关系。
